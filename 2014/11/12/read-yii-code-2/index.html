<!DOCTYPE html>
<html lang="zh">
<head>

        <title>Yii源码阅读笔记 - 路由解析</title>
        <meta charset="utf-8" />
        <link href="http://youngsterxyf.github.io/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="黑 * 白 Full Atom Feed" />
        <link href="http://youngsterxyf.github.io/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="黑 * 白 Full RSS Feed" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="../../../../theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/style.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/pygment.css" />

        <script src="../../../../theme/js/libs/jquery-1.9.1.min.js"></script>
        <script src="../../../../theme/js/libs/modernizr-2.6.2.min.js"></script>

              <script>
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-43488080-1', '黑白');
                ga('send', 'pageview');

              </script>

              <script type="text/javascript" src="http://tajs.qq.com/stats?sId=27164999" charset="UTF-8"></script>
</head>

<body id="index" class="home">
    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1><a href="../../../..">黑 * 白 <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>

              <ul class="columns">
                <li><a href="../../../..">主 页</a></li>

                <li><a href="/archives.html">归 档</a></li>
                <li><a href="/tags.html">标 签</a></li>
                <li><a href="/pages/tools.html">工具集</a></li>
                <li><a href="/pages/links.html">链 接</a></li>
                <li><a href="/pages/tech-share.html">技术分享</a></li>
                <li><a href="/pages/aboutme.html">关于我</a></li>
                <li><a href="/feeds/rss.xml">RSS</a></li>

              </ul>
            </div>

<section id="content" class="body">
   <div class="row">
        <div class="columns">
            <header>
              <h2 class="entry-title">
                <a href="../../../../2014/11/12/read-yii-code-2/" rel="bookmark" title="Permalink to Yii源码阅读笔记 - 路由解析">Yii源码阅读笔记 - 路由解析</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="2014-11-12T00:00:00">
                2014-11-12 Wed
              </abbr>
              <address class="vcard author">
                By <a class="url fn" href="../../../../author/youngsterxyf.html">youngsterxyf</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <h3 id="_1">概述</h3>
<p>Yii框架的路由解析功能由核心组件urlManager来完成。路由的形式有两种：</p>
<ul>
<li>get：通过URL中查询字符串（query string）参数r来指定路由，如：<code>r=controllerID/actionID</code></li>
<li>path：直接通过URL来指定，如：<code>/controllerID/actionID</code></li>
</ul>
<p>默认使用get路由形式。由于Yii中controller类命名和action方法都是按照规则命名的，而路由也是按照规则来匹配的，所以完全可以不用额外配置urlManager。</p>
<p>若需要使用path方式，则可如下配置：</p>
<pre><code>:::php
"components" =&gt; array(
    'urlManager' =&gt; array(
        'urlFormat' =&gt; 'path',
        'rules' =&gt; array(
            ...
        ),
),
</code></pre>
<p>进一步说明可参考<a href="http://youngsterxyf.github.io/2014/09/06/experience-about-restful-api/">RESTful API设计的一点经验</a>一文。</p>
<h3 id="_2">分析</h3>
<p>在“请求处理基本流程”一篇可以看到Yii框架路由解析流程的入口在类CWebApplication的processRequest方法中：</p>
<pre><code>:::php
$route=$this-&gt;getUrlManager()-&gt;parseUrl($this-&gt;getRequest());
</code></pre>
<p>其中getUrlManager方法定义于类CApplication中，作用是初始化获取URL管理组件（ID为urlManager），实现如下：</p>
<pre><code>:::php
public function getUrlManager()
{
    return $this-&gt;getComponent('urlManager');
}
</code></pre>
<p>在获取urlManager组件对象过程中，会对对象做初始化，调用对象的init方法，见类CUrlManager的init方法实现：</p>
<pre><code>:::php
public function init()
{
    parent::init();
    $this-&gt;processRules();
}
</code></pre>
<p>其中调用的方法processRules，是根据配置的rules解析创建规则对象，放到属性_rules中，实现如下：</p>
<pre><code>:::php
protected function processRules()
{
    // 如果未配置rules，或使用的路由形式是get，则根本无需解析路由规则
    if(empty($this-&gt;rules) || $this-&gt;getUrlFormat()===self::GET_FORMAT)
        return;
    // 否则尝试从缓存中读取解析好的路由规则
    if($this-&gt;cacheID!==false &amp;&amp; ($cache=Yii::app()-&gt;getComponent($this-&gt;cacheID))!==null)
    {
        $hash=md5(serialize($this-&gt;rules));
        if(($data=$cache-&gt;get(self::CACHE_KEY))!==false &amp;&amp; isset($data[1]) &amp;&amp; $data[1]===$hash)
        {
            $this-&gt;_rules=$data[0];
            return;
        }
    }
    // 否则逐条路由规则解析
    foreach($this-&gt;rules as $pattern=&gt;$route)
        $this-&gt;_rules[]=$this-&gt;createUrlRule($route,$pattern);
    // 尝试缓存解析好的路由规则
    if(isset($cache))
        $cache-&gt;set(self::CACHE_KEY,array($this-&gt;_rules,$hash));
}
</code></pre>
<p>从上述代码中，在解析创建规则对象前会先检查是否已缓存了解析创建好的规则，如果没有，则在解析创建好规则后，将这些规则缓存起来。这样就避免了每次请求处理都要解析一次rules列表。
但这里需要注意的是<strong>urlManager组件默认使用ID为<code>cache</code>的缓存组件（CUrlManager类的属性cacheID默认值为cache），而核心组件并不包含ID为<code>cache</code>的缓存组件，所以若希望缓存解析好路由规则，
则应该配置ID为cache的缓存组件，如果缓存组件的ID不是cache，则需要配置urlManager组件的cacheID属性</strong>。</p>
<p>如果没有设置缓存组件，或者缓存中未找到解析好的路由规则，则需要对配置的rules逐条解析，解析过程见类CUrlManager的createUrlRule方法实现：</p>
<pre><code>:::php
/**
 * Creates a URL rule instance.
 * The default implementation returns a CUrlRule object.
 * @param mixed $route the route part of the rule. This could be a string or an array
 * @param string $pattern the pattern part of the rule
 * @return CUrlRule the URL rule instance
 * @since 1.1.0
 */
protected function createUrlRule($route,$pattern)
{
    // 说明可以配置自定义的路由规则解析类
    if(is_array($route) &amp;&amp; isset($route['class']))
        return $route;
    else
    {
        $urlRuleClass=Yii::import($this-&gt;urlRuleClass,true);
        return new $urlRuleClass($route,$pattern);
    }
}
</code></pre>
<p>以以下rules配置为例：</p>
<pre><code>:::php
'rules' =&gt; array(
    array('industry/index', 'pattern' =&gt; '/v1/partner/industry/', 'verb' =&gt; 'GET'),
    array('token/create', 'pattern' =&gt; '/v1/partner/token', 'verb' =&gt; 'POST'),
)
</code></pre>
<p>在处理第一条规则时，方法createUrlRule的参数$pattern的值为数组的索引0，$route的值为关联数组<code>array('industry/index', 'pattern' =&gt; '/v1/partner/industry/', 'verb' =&gt; 'GET')</code>，
但因为$route里没有设置class字段，所以走的是else分支 - 先引入类CUrlRule（$this-&gt;urlRuleClass的默认值），然后根据$route、$pattern实例化类CUrlRule，该类也定义在文件<code>yii/framework/web/CUrlManager.php</code>中，
直接继承自抽象类CBaseUrlRule。CUrlRule的构造方法实现如下：</p>
<pre><code>:::php
public function __construct($route,$pattern)
{
    if(is_array($route))
    {
        // 从这里可知$route支持'urlSuffix', 'caseSensitive', 'defaultParams', 'matchValue', 'verb', 'parsingOnly'这些配置项
        foreach(array('urlSuffix', 'caseSensitive', 'defaultParams', 'matchValue', 'verb', 'parsingOnly') as $name)
        {
            if(isset($route[$name]))
                $this-&gt;$name=$route[$name];
        }
        // 如果$route中有pattern配置项，则将配置值赋值给$pattern
        if(isset($route['pattern']))
            $pattern=$route['pattern'];
        // 而$route的第一个配置项才是真正的目标路由
        $route=$route[0];
    }
    $this-&gt;route=trim($route,'/');

    $tr2['/']=$tr['/']='\\/';

    if(strpos($route,'&lt;')!==false &amp;&amp; preg_match_all('/&lt;(\w+)&gt;/',$route,$matches2))
    {
        foreach($matches2[1] as $name)
            $this-&gt;references[$name]="&lt;$name&gt;";
    }

    // 是否带协议头
    $this-&gt;hasHostInfo=!strncasecmp($pattern,'http://',7) || !strncasecmp($pattern,'https://',8);

    // 如果原$route有verb配置项
    // verb配置支持多个HTTP方法，以空格或逗号分隔，如：“GET,POST”
    if($this-&gt;verb!==null)
        $this-&gt;verb=preg_split('/[\s,]+/',strtoupper($this-&gt;verb),-1,PREG_SPLIT_NO_EMPTY);

    // $pattern中类正则片段支持两种形式：命名的和未命名的，如“&lt;id:\d+&gt;”和“&lt;\d+&gt;”
    if(preg_match_all('/&lt;(\w+):?(.*?)?&gt;/',$pattern,$matches))
    {
        $tokens=array_combine($matches[1],$matches[2]);
        foreach($tokens as $name=&gt;$value)
        {
            if($value==='')
                $value='[^\/]+';
            $tr["&lt;$name&gt;"]="(?P&lt;$name&gt;$value)";
            if(isset($this-&gt;references[$name]))
                $tr2["&lt;$name&gt;"]=$tr["&lt;$name&gt;"];
            else
                $this-&gt;params[$name]=$value;
        }
    }
    // 好吧，之后的这段代码我还没太看懂作用
    // 就是为了将$pattern转换成一个真正的正则表达式？
    $p=rtrim($pattern,'*');
    $this-&gt;append=$p!==$pattern;
    $p=trim($p,'/');
    $this-&gt;template=preg_replace('/&lt;(\w+):?.*?&gt;/','&lt;$1&gt;',$p);
    $this-&gt;pattern='/^'.strtr($this-&gt;template,$tr).'\/';
    if($this-&gt;append)
        $this-&gt;pattern.='/u';
    else
        $this-&gt;pattern.='$/u';

    if($this-&gt;references!==array())
        $this-&gt;routePattern='/^'.strtr($this-&gt;route,$tr2).'$/u';

    if(YII_DEBUG &amp;&amp; @preg_match($this-&gt;pattern,'test')===false)
        throw new CException(Yii::t('yii','The URL pattern "{pattern}" for route "{route}" is not a valid regular expression.',
            array('{route}'=&gt;$route,'{pattern}'=&gt;$pattern)));
}
</code></pre>
<hr />
<p>在得到<strong>urlManager组件对象</strong>后，调用其parseUrl方法，实现如下：</p>
<pre><code>:::php
public function parseUrl($request)
{
    if($this-&gt;getUrlFormat()===self::PATH_FORMAT)
    {
        $rawPathInfo=$request-&gt;getPathInfo();
        $pathInfo=$this-&gt;removeUrlSuffix($rawPathInfo,$this-&gt;urlSuffix);
        foreach($this-&gt;_rules as $i=&gt;$rule)
        {
            if(is_array($rule))
                $this-&gt;_rules[$i]=$rule=Yii::createComponent($rule);
            // 逐个路由规则匹配
            if(($r=$rule-&gt;parseUrl($this,$request,$pathInfo,$rawPathInfo))!==false)
                // 即使匹配到了路由规则，也还是得看一下URL中是否指定了路由，是的话则优先使用URL中指定的路由
                return isset($_GET[$this-&gt;routeVar]) ? $_GET[$this-&gt;routeVar] : $r;
        }
        // 如果一定要匹配到某个路由规则才行，那么执行到这里就表示未有匹配的路由规则，所以就抛404错误了。
        if($this-&gt;useStrictParsing)
            throw new CHttpException(404,Yii::t('yii','Unable to resolve the request "{route}".',
                array('{route}'=&gt;$pathInfo)));
        // 否则先返回请求路径作为目标路由
        else
            return $pathInfo;
    }
    // 如果使用的是get路由形式，则从GET请求的查询字符串或POST请求的请求体找目标路由
    elseif(isset($_GET[$this-&gt;routeVar]))
        return $_GET[$this-&gt;routeVar];
    elseif(isset($_POST[$this-&gt;routeVar]))
        return $_POST[$this-&gt;routeVar];
    else
        return '';
}
</code></pre>
<p>方法的参数是一个request组件对象。</p>
<p>先判断应用使用的路由形式是否为path，如果不是，则根据路由的参数名（默认为<code>r</code>，由于urlManager类的routeVar属性是public的，所以可以通过配置routeVar的值来修改路由参数名）获取路由。并且路由可以通过GET方法放在URL查询字符串中，也可以通过POST方法放在请求体中。</p>
<p>对于path形式的路由，解析过程则要复杂一些。先通过request组件对象的getPathInfo方法取到请求的URL（会对原本的请求URL做一定的处理），然后根据解析好的路由规则列表逐个匹配。其中<strong>CUrlRule类</strong>的parseUrl方法实现如下：</p>
<pre><code>:::php
public function parseUrl($manager,$request,$pathInfo,$rawPathInfo)
{
    // 先检查HTTP谓词（verb）是否匹配
    if($this-&gt;verb!==null &amp;&amp; !in_array($request-&gt;getRequestType(), $this-&gt;verb, true))
        return false;
    // 是否关心大小写
    if($manager-&gt;caseSensitive &amp;&amp; $this-&gt;caseSensitive===null || $this-&gt;caseSensitive)
        $case='';
    else
        $case='i';

    // urlSiffix配置项是用来干嘛的？
    if($this-&gt;urlSuffix!==null)
        $pathInfo=$manager-&gt;removeUrlSuffix($rawPathInfo,$this-&gt;urlSuffix);

    // URL suffix required, but not found in the requested URL
    if($manager-&gt;useStrictParsing &amp;&amp; $pathInfo===$rawPathInfo)
    {
        $urlSuffix=$this-&gt;urlSuffix===null ? $manager-&gt;urlSuffix : $this-&gt;urlSuffix;
        if($urlSuffix!='' &amp;&amp; $urlSuffix!=='/')
            return false;
    }

    if($this-&gt;hasHostInfo)
        $pathInfo=strtolower($request-&gt;getHostInfo()).rtrim('/'.$pathInfo,'/');

    $pathInfo.='/';

    // 正则匹配：用pattern来匹配路径
    if(preg_match($this-&gt;pattern.$case,$pathInfo,$matches))
    {
        // 可以配置defaultParams数组来为请求未提供的必要参数指定默认值
        foreach($this-&gt;defaultParams as $name=&gt;$value)
        {
            if(!isset($_GET[$name]))
                $_REQUEST[$name]=$_GET[$name]=$value;
        }
        $tr=array();
        foreach($matches as $key=&gt;$value)
        {
            if(isset($this-&gt;references[$key]))
                $tr[$this-&gt;references[$key]]=$value;
            elseif(isset($this-&gt;params[$key]))
                $_REQUEST[$key]=$_GET[$key]=$value;
        }
        if($pathInfo!==$matches[0]) // there're additional GET params
            $manager-&gt;parsePathInfo(ltrim(substr($pathInfo,strlen($matches[0])),'/'));
        if($this-&gt;routePattern!==null)
            return strtr($this-&gt;route,$tr);
        else
            return $this-&gt;route;
    }
    else
        return false;
}
</code></pre>
<p>从上述代码可以看出，路由解析关键是根据$pattern匹配请求URL，并<strong>从URL取出需要的东西作为请求参数</strong>，一旦匹配，就以$route作为该次请求的目标路由。</p>
<p>获得目标路由后，就可以根据目标路由查找调用对应的controller和action了。</p>
            </div><!-- /.entry-content -->
            <div class="comments">
              <h3>Comments</h3>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
                var disqus_identifier = "2014/11/12/read-yii-code-2/";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://xiayfblackwhite.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
              </script>
            </div>
        </div><!-- /.twelve.columns -->
 </div><!-- /.row -->
</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">


        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">

                <li><div class="btn primary"><a href="http://github.com/youngsterxyf" target="_blank">Github</a></div></li>

                <li><div class="btn twitter"><a href="https://twitter.com/youngsterxyf" target="_blank">Twitter</a></div></li>

                <li><div class="btn warning"><a href="http://weibo.com/u/1855563263" target="_blank">Weibo</a></div></li>

                <li><div class="btn douban"><a href="http://www.douban.com/people/youngster21/" target="_blank">Douban</a></div></li>



              </ul>
            </div>
          </div>
        </footer>

    </div>


<script type="text/javascript">
    var disqus_shortname = 'xiayfblackwhite';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
  <script src="../../../../theme/js/libs/gumby.min.js"></script>
  <script src="../../../../theme/js/plugins.js"></script>
  <script src="../../../../theme/js/main.js"></script>
</body>
</html>