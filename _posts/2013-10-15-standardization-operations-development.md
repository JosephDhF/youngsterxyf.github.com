---
layout: post
title: 运营开发规范化的几项工作
tags: [服务器, Linux, Git, Golang, Python]
---

入职腾讯做运营开发6个月有余。入职之时组内仅有1个运营开发的同事，到目前已扩充到5人，加3个实习生。

入职之时的运营开发过程是这样的：

1.
在办公机器（Windows）上编写代码，功能测试通过后，

2.
ssh远程连接到生产服务器（Linux），vim打开一个新文件，复制办公机器上的代码，粘贴到vim中，保存，

3.
打开浏览器测试上线的功能/效果是否正确，若不正确，

4.
直接在生产服务器上编辑代码文件，直到达到需要的功能效果，

5.
再从生产服务器上将修改后的代码复制粘贴到办公机器（也许不会有这一步，之后所有的修改都直接在生产服务器上操作）。

这个过程存在如下问题：

1.
代码没有版本控制

2.
没有与生产服务器一致的测试环境

3.
代码部署过程繁琐

4.
办公开发机器上代码很可能比生产服务器上代码还旧

5.
上面4点都会导致混乱

除此之外，当团队从1人扩充到多人后，不可避免地会遇到协作的问题，解决代码开发协作问题一般涉及如下几方面：

1.
使用代码版本控制

2.
规定版本控制的工作流

3.
编码规范

4.
项目/代码文档

5.
定期code review

为了解决上述问题，我陆续地做了如下工作：

### 搭建Gitlab服务器、测试服务器

个人认为开发工作规范化的第一点就是版本控制，基于版本控制可以完成很多自动化的任务。

平时个人的代码、文档都通过Git版本控制存放在Github上，所以选择Gitlab来自建类Github平台，服务器的搭建过程见： [搭建测试服务器(源码编译方式)](http://youngsterxyf.github.io/2013/06/18/setup-testing-server/)。

测试服务器和Gitlab服务器是同一台机器，在Git服务器端某个版本库的hooks目录下添加post-receive hook脚本，当有代码提交时，触发执行该脚本，脚本会将该版本库各个分支的代码更新到特定目录中，
然后以每个目录为root添加Nginx虚拟主机配置。这样每次代码提交后，就可以直接打开浏览器查看效果了。hook脚本代码见：[post-receive.py](https://gist.github.com/youngsterxyf/6988132)。

该hook脚本的实现比较暴力---任何代码提交都会检查签出所有分支代码。

目前为止，Gitlab平台已得到较好的使用，但由于所要开发的运营平台涉及到一些监控数据API问题，很难有效地使用测试服务器，所以测试服务器一直没有正式使用起来。

### 选择一种Git工作流

若是单个使用Git，那么Git的工作流基本上就是：`git status`，`git add xxx`， `git commit -m "xxx"`，`git pull`，`git push origin master`。

当涉及多人协作时，为了减少手动合并代码的工作量以及尽可能避免污染Git远程服务器版本信息，Git工作流就要复杂一些。

我们的Git工作流如图所示：

![our-git-workflow](https://raw.github.com/youngsterxyf/youngsterxyf.github.com/master/assets/pics/git-workflow.png)

Git远程服务器端和办公机端版本库都保持两个共享分支：master和develop。master分支是稳定分支，其最新代码与生产服务器上的代码一致。develop是测试分支。

开发人员开发新功能或fix bug时，先在本地机器从master分支创建一个非共享分支xxx，在xxx分支中编写代码；需要在测试服务器测试代码时，将xxx分支合并入develop分支，将develop分支push到远程服务器；
经测试后，确定需要上线生产服务器，则将xxx分支合并入master分支，并push远程服务器，生产服务器从master分支pull代码进行部署。

这种工作流能避免“先提交的代码后上线”而导致的版本回滚问题。

### 生产服务器上的代码迁入版本控制

这项工作虽然工作量不大，却值得一提。因为不能影响正常的服务，也不能导致任何文件的丢失损坏，所以应该慎之又慎。

我选择周末在公司完成该工作，过程如下：

1.
在Gitlab上新建一个版本库，如*xxx*；

2.
将生产服务器上的代码打包备份一下；

3.
进入代码根目录，执行`git init`；

4.
创建编写.gitignore文件，因为一些非代码文件，如图片、视频等，是不需要进入版本控制的，应告诉git忽略。注意：已进入版本控制的文件，即使在.gitignore里列出，git也不会忽略的。
由于文件比较多，目录结构比较复杂，所以可能很难一次性找到所有需要过滤的文件，可以先`git add *`，然后通过`git status`来查看哪些文件已被加入暂存区，如果有需要过滤的文件被加入了暂存区，则执行`git reset`取消
暂存区内容，再次编辑.gitignore；

5.
确认需要过滤的文件都能被.gitignore中的内容匹配后执行`git add * && git commit -m "init"`；

6.
将本地的git版本库与Gitlab服务器端的git版本库关联起来。假设Gitlab服务器端版本库的http链接为*http://gitlab.server.com/xxx.git*，执行`git remote add origin http://gitlab.server.com/xxx.git`；

7.
将本地版本库代码推送到远程Gitlab服务器端。执行`git push origin master`。

这样，生产服务器上的代码就迁入版本控制了，之后代码部署，只需从Git远程服务器拉取（pull）一下就可以了。

代码部署过程，原本也想通过hook方式---在代码提交进入master分支时，触发hook脚本，将master分支最新的代码拉取到生产服务器上，但一方面由于网络设定---测试服务器不能主动连接生产服务器，
另一方面谨慎起见，没有采用这种自动方式。在代码提交到Gitlab服务器端后，需要登录到生产服务器执行`git pull`。

### 项目/代码文档


### 规范化运营开发宣导


### 如何推行“定期code review”


### 如何推行“编码规范”
