《Linux/UNIX系统编程手册》读书笔记
========================================

第2章：基本概念
-------------------

一般情况下，Linux内核可执行文件采用/boot/vmlinuz或与之类似的路径名。早期的UNIX实现称其内核为UNIX。在后续实现了虚拟内存机制的UNIX系统中，其内核名称变更为vmunix。对Linux来说，文件名称中的系统名需要调整，而以“z”替换“linux”末尾的“x”，意在表明内核是经过压缩的可执行文件。


在文件系统内，会对文件类型进行标记，以表明其种类。其中一种用来表示普通数据文件，常称之为“普通文件”或“纯文本文件”。其他文件类型包括设备、管道、套接字、目录以及符号链接。

目录是一种特殊类型的文件，内容采用表格形式，数据项包括文件名以及对相应文件的引用。这一“文件名+引用”的组合被称为链接。每个文件都可以有多条链接，因而也可以有多个名称，在相同或不同的目录中出现。


进程的当前工作目录继承自其父进程。


每个文件都有一个与之相关的用户ID和组ID，分别定义文件的属主和属组。系统根据文件的所有权来判定用户对文件的访问权限。

对于目录而言，权限设置的意义与文件不同： **读权限允许列出目录内容（即该目录下的文件名），写权限允许对目录内容进行更改（比如，添加、修改或删除文件名），执行（有时也称为搜索）权限允许对目录中的文件进行访问（但需受文件自身访问的权限的约束）** 。


进程的内存布局 - 逻辑上将一个进程划分为以下几部分（也称为段）：

- 文本：程序的指令
- 数据：程序使用的静态变量
- 堆：程序可以从该区域动态分配额外内存
- 栈：随函数调用、返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间


内核通过对父进程的复制来创建子进程。子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不会影响父进程的“原版”内容。（在内存中被标记为只读的程序文本段则由父、子进程共享。）

然后，子进程要么去执行与父进程共享代码段中的另一组不同函数，或者，更为常见的情况是使用系统调用execve()去加载并执行一个全新程序。execve()会销毁现有的文本段、数据段、栈段及堆段，并根据新程序的代码，创建新段来替换它们。

可使用以下两种方式之一来终止一个进程：其一，进程可使用 ``_exit()`` 系统调用（或相关的 ``exit()`` 库函数），请求退出；其二，向进程传递信号，将其“杀死”。无论以何种方式退出，进程都会生成“终止状态”，一个非负小整数，可供父进程的 ``wait()`` 系统调用检测。


**进程的用户和组标识符（凭证）**

每个进程都有一组与之相关的用户ID（UID）和组ID（GID）：

- 真实用户ID和组ID：用来标识进程所属的用户和组。新进程从其父进程处继承这些ID。登录shell则会从系统密码文件的相应字段中获取其真实用户ID和组ID。
- 有效用户ID和组ID：进程在访问受保护资源（比如，文件和进程间通信对象）时，会使用这两个ID（并结合下述的补充组ID）来确定访问权限。一般情况下，进程的有效ID和相应的真实ID值相同。改变进程的有效ID实为一种机制，可使进程具有其他用户或组的权限（命令 ``sudo`` 的作用？）
- 补充组ID：用来标识进程所属的额外组。新进程从其父进程处继承补充组ID。登录shell则从系统组文件中获取其补充组ID。


每个进程都会消耗诸如打开文件、内存以及CPU时间之类的资源。使用系统调用 ``setrlimit()`` ，进程可为自己消耗的各类资源限定一个上限。此类资源限制的每一项均有两个相关值：软限制（soft limit）限制了进程可以消耗的资源总量，硬限制（hard limit）限制软限制的调整上限。非特权进程在针对特定资源调整软限制值时，可将其设置为0到相应硬限制值之间的任意值，但硬限制值则只能调低，不能调高。

由 ``fork()`` 创建的新进程，会继承其父进程对资源限制的设置。

使用ulimit命令可调整shell的资源限制。shell为执行命令所创建的子进程会继承上述资源设置。

